{"ast":null,"code":"/*\n * JavaScript Load Image Meta\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Image meta data handling implementation\n * based on the help and contribution of\n * Achim StÃ¶hr.\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, DataView, Uint8Array */\n\n;\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  var hasblobSlice = typeof Blob !== 'undefined' && (Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice);\n  loadImage.blobSlice = hasblobSlice && function () {\n    var slice = this.slice || this.webkitSlice || this.mozSlice;\n    return slice.apply(this, arguments);\n  };\n  loadImage.metaDataParsers = {\n    jpeg: {\n      0xffe1: [],\n      // APP1 marker\n      0xffed: [] // APP13 marker\n    }\n  };\n\n  // Parses image meta data and calls the callback with an object argument\n  // with the following properties:\n  // * imageHead: The complete image head as ArrayBuffer (Uint8Array for IE10)\n  // The options argument accepts an object and supports the following\n  // properties:\n  // * maxMetaDataSize: Defines the maximum number of bytes to parse.\n  // * disableImageHead: Disables creating the imageHead property.\n  loadImage.parseMetaData = function (file, callback, options, data) {\n    // eslint-disable-next-line no-param-reassign\n    options = options || {};\n    // eslint-disable-next-line no-param-reassign\n    data = data || {};\n    var that = this;\n    // 256 KiB should contain all EXIF/ICC/IPTC segments:\n    var maxMetaDataSize = options.maxMetaDataSize || 262144;\n    var noMetaData = !(typeof DataView !== 'undefined' && file && file.size >= 12 && file.type === 'image/jpeg' && loadImage.blobSlice);\n    if (noMetaData || !loadImage.readFile(loadImage.blobSlice.call(file, 0, maxMetaDataSize), function (e) {\n      if (e.target.error) {\n        // FileReader error\n        // eslint-disable-next-line no-console\n        console.log(e.target.error);\n        callback(data);\n        return;\n      }\n      // Note on endianness:\n      // Since the marker and length bytes in JPEG files are always\n      // stored in big endian order, we can leave the endian parameter\n      // of the DataView methods undefined, defaulting to big endian.\n      var buffer = e.target.result;\n      var dataView = new DataView(buffer);\n      var offset = 2;\n      var maxOffset = dataView.byteLength - 4;\n      var headLength = offset;\n      var markerBytes;\n      var markerLength;\n      var parsers;\n      var i;\n      // Check for the JPEG marker (0xffd8):\n      if (dataView.getUint16(0) === 0xffd8) {\n        while (offset < maxOffset) {\n          markerBytes = dataView.getUint16(offset);\n          // Search for APPn (0xffeN) and COM (0xfffe) markers,\n          // which contain application-specific meta-data like\n          // Exif, ICC and IPTC data and text comments:\n          if (markerBytes >= 0xffe0 && markerBytes <= 0xffef || markerBytes === 0xfffe) {\n            // The marker bytes (2) are always followed by\n            // the length bytes (2), indicating the length of the\n            // marker segment, which includes the length bytes,\n            // but not the marker bytes, so we add 2:\n            markerLength = dataView.getUint16(offset + 2) + 2;\n            if (offset + markerLength > dataView.byteLength) {\n              // eslint-disable-next-line no-console\n              console.log('Invalid meta data: Invalid segment size.');\n              break;\n            }\n            parsers = loadImage.metaDataParsers.jpeg[markerBytes];\n            if (parsers && !options.disableMetaDataParsers) {\n              for (i = 0; i < parsers.length; i += 1) {\n                parsers[i].call(that, dataView, offset, markerLength, data, options);\n              }\n            }\n            offset += markerLength;\n            headLength = offset;\n          } else {\n            // Not an APPn or COM marker, probably safe to\n            // assume that this is the end of the meta data\n            break;\n          }\n        }\n        // Meta length must be longer than JPEG marker (2)\n        // plus APPn marker (2), followed by length bytes (2):\n        if (!options.disableImageHead && headLength > 6) {\n          if (buffer.slice) {\n            data.imageHead = buffer.slice(0, headLength);\n          } else {\n            // Workaround for IE10, which does not yet\n            // support ArrayBuffer.slice:\n            data.imageHead = new Uint8Array(buffer).subarray(0, headLength);\n          }\n        }\n      } else {\n        // eslint-disable-next-line no-console\n        console.log('Invalid JPEG file: Missing JPEG marker.');\n      }\n      callback(data);\n    }, 'readAsArrayBuffer')) {\n      callback(data);\n    }\n  };\n\n  // Replaces the image head of a JPEG blob with the given one.\n  // Calls the callback with the new Blob:\n  loadImage.replaceHead = function (blob, head, callback) {\n    loadImage.parseMetaData(blob, function (data) {\n      callback(new Blob([head, loadImage.blobSlice.call(blob, data.imageHead.byteLength)], {\n        type: 'image/jpeg'\n      }));\n    }, {\n      maxMetaDataSize: 256,\n      disableMetaDataParsers: true\n    });\n  };\n  var originalTransform = loadImage.transform;\n  loadImage.transform = function (img, options, callback, file, data) {\n    if (loadImage.hasMetaOption(options)) {\n      loadImage.parseMetaData(file, function (data) {\n        originalTransform.call(loadImage, img, options, callback, file, data);\n      }, options, data);\n    } else {\n      originalTransform.apply(loadImage, arguments);\n    }\n  };\n});","map":null,"metadata":{},"sourceType":"script"}